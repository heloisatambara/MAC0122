from time import time

 # função para leitura dos arquivos
def func(arq):
    matriz = [] #declaro vetor
    texto = arq.readlines() #quebra as linhas do arquivo em vetores 
    
    for i in range(len(texto)):  # percorre os vetores
        texto[i] = texto[i].replace('\n', '')  # tira os '\n'
        matriz.append(texto[i].split(','))  # quebra nas vírgulas

     # tratando as datas
    for i in range(len(matriz)):
        matriz[i][2] = matriz[i][2].split('/')
        matriz[i][2].sort(reverse=True)
        
    return matriz
#


 # função para definir as prioridades
def clasf(clas):
    k = clas % 10 # ultimo digito 
    j = (clas - k) % 100 # segundo
    i = clas - k - j # primeiro
    return (i, j, k)

               
                
#





'''
while j > 0 and tab[priority[0]][j] < tab[priority[0]][j - 1]:
            # troca com o seu vizinho
            tab[priority[0]][j], tab[priority[0]][j - 1] = tab[priority[0]][j - 1], tab[priority[0]][j]
            # continua subindo
            j = j - 1



1 - id
2 - nome
3 - data
possibilidades: 123, 132, 213, 231, 321, 312
'''

 # bolha
def Bolha(a, p=(0,1,2)): 
    # i = 1, 2, ..., n - 1
    for i in range(1, len(a)):
    # sobe com a[i] até encontrar o lugar adequado
        j = i
        while j > 0 and a[j][p[0]] < a[j - 1][p[0]]:
            if a[j][p[0]] == a[j - 1][p[0]]:
                if a[j][p[1]] == a[j - 1][p[1]]:
                    while j > 0 and a[j][p[1]] < a[j - 1][p[1]]:
                        # troca com o seu vizinho
                        a[j], a[j - 1] = a[j - 1], a[j]
                        # continua subindo
                        j = j - 1
                        # troca com o seu vizinho
                while j > 0 and a[j][p[1]] < a[j - 1][p[1]]:
                    # troca com o seu vizinho
                    a[j], a[j - 1] = a[j - 1], a[j]
                    # continua subindo
                    j = j - 1
                    # troca com o seu vizinho
                    
            a[j], a[j - 1] = a[j - 1], a[j]
            # continua subindo
            j = j - 1
#


 # quick
def particiona(lista, inicio, fim, p):
    # Particiona a lista de lista{inicio] até lista[fim]
    i, j = inicio, fim
    # Direção - dir == 1 esquerda-direita e dir == -1 ao contrário
    dir = 1
    while i < j:
        if lista[i][p[0]] > lista[j][p[0]]:
            lista[i], lista[j] = lista[j], lista[i]
            # muda a direção
            dir = - dir
        elif lista[i][p[0]] == lista[j][p[0]]: 
            if lista[i][p[1]] > lista[j][p[1]]:
                lista[i], lista[j] = lista[j], lista[i]
                # muda a direção
                dir = - dir
            elif lista[i][p[1]] == lista[j][p[1]]:
                if lista[i][p[2]] > lista[j][p[2]]:
                    lista[i], lista[j] = lista[j], lista[i]
                    # muda a direção
                    dir = - dir
         # incrementa i ou decrementa j
        if dir == 1: i = i + 1
        else: j = j - 1
    # Devolve o índice do elemento pivô
    return i


def Quick_Sort(lista, inicio, fim, p=(0,1,2)):
    # Se a lista tem mais de um elemento, ela será
    # particionada e as duas partições serão classificadas
    # pelo mesmo método Quick Sort
    if inicio < fim:
        k = particiona(lista, inicio, fim,  p)
        Quick_Sort(lista, inicio, k - 1, p)
        Quick_Sort(lista, k + 1, fim, p)
 #



 # rodar programa
def main():
    while True:
         # Pedir o nome do arquivo de origem (‘fim’: break)
        arq =  'arq.txt' #input('Nome do arquivo de origem: ')
        if arq == 'fim': break
        else: arq = open(arq, 'r')

         # Ler o arquivo de origem e colocar em TAB (já com split(‘,’) dos campos)
        TAB = func(arq)
        TAB1, TAB2 = TAB[:], TAB[:] # TAB1 = TAB2 = TAB  (2 cópias de TAB)

        while True:
             # Pedir a ordem (número inteiro que seja permutação de 123) (‘fim’: break)
            clas = '123' # input('Ordem de classificação: ')
            if clas == 'fim': break
            else:
                clas = int(clas)
                clas = clasf(clas)
            if clas == (1,2,3):
                def pri(elem):
                    return (elem[1-1], elem[2-1], elem[3-1])                
            elif clas == (1,3,2):
                def pri(elem):                               
                    return (elem[1-1], elem[3-1], elem[2-1])                
            elif clas == (2,1,3):                
                def pri(elem):                
                    return (elem[2-1], elem[1-1], elem[3-1])
            elif clas == (2,3,1):                                
                def pri(elem):                
                    return (elem[2-1], elem[3-1], elem[1-1])                
            elif clas == (3,1,2):                
                def pri(elem):                
                    return (elem[3-1], elem[1-1], elem[2-1])                
            elif clas == (3,2,1):                
                def pri(elem):                
                    return (elem[3-1], elem[2-1], elem[1-1])



             # ClassificarSort(TAB, ordem) – cronometrar e mostrar o tempo gasto
            tsort1 = time()
            TAB.sort(key=pri)
            tsort2 = time()
            print('Tempo de classificação Sort() =', tsort2 - tsort1)

             # ClassificarBolha(TAB1, ordem) – cronometrar e mostrar o tempo gasto
            tbol1 = time()
            TAB1 = TAB1.Bolha()
            tbol2 = time()
            print('Tempo de classificação Bolha =', tbol2 - tbol1 )
             # Comparar TAB1 com TAB para ver se classificou corretamente
            if TAB1 == TAB: print('*** Classificação correta')
            else: print('*** Classificação incorreta.')

             # ClassificarQuick(TAB2, ordem) – cronometrar e mostrar o tempo gasto
            tq1 = time()
            TAB2 = TAB2.Quick_sort()
            tq2 = time()
            print('Tempo de classificação do Quick =', tq2 - tq1)
             # Comparar TAB2 com TAB para ver se classificou corretamente
            if TAB2 == TAB: print('*** Classificação correta')
            else: print('*** Classificação incorreta.')
#

# caminho: E:\usp\programacoes\mac\arq.txt

main()

