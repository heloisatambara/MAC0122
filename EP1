# Exercício Programa I – MAC 122 – PDA
# Heloisa Tambara 
import re

class Pilha:
    def __init__(self):
        self._pilha = []
        
    def __len__(self):
        return len(self._pilha)
    
    def stack(self, a):
        self._pilha.append(a)
        
    def pop(self):
        return self._pilha.pop()

    def top(self):
        return self._pilha[-1]


def pri(x):
    if x == '+': return 1
    elif x == '-': return 1
    elif x == '*': return 2
    elif x == '/': return 2
    elif x == '**': return 3
    elif x == '(': return 4 # caso particular
    elif x == ')': return 5 # caso particular
    else: return 0 # não é operador

def op(num1, operator, num2):
    if operator == '+':
        return num1 + num2
    elif operator == '-':
        return num1 - num2
    elif operator == '*':
        return num1 * num2
    elif operator == '/':
        return num1 / num2
    elif operator == '**':
        return num1 ** num2
# starters
expr = input() # ask for the expression
exprli = re.findall(r"(\b\w*[\.]?\w+\b|[\(\)\+\*\-\/])", expr)
oppile = Pilha()
pexpr = []
#

print(exprli)

# creating the expression
for k in range(len(exprli)-1):
    if exprli[k] == '*' and exprli[k+1] == '*':
        exprli[k] = '**'
        del exprli[k+1]
    if '0' < exprli[k][0] < '9':
        exprli[k] = int(exprli[k])
print(exprli)

for k in range(len(exprli)):
    p = exprli[k]
    if type(p) == int: # if it's a number
        pexpr.append(exprli[k])
    elif  0 < pri(p) < 4 : # if it's an operator
        while len(oppile) > 0:
            if 4 > pri(oppile.top()) >= pri(p):
                pexpr.append(oppile.pop())
            else:
                break
            
        oppile.stack(p)
        # tire da pilha e coloque na pós-fixa todos os operadores
        # com prioridade maior ou igual a p, na mesma ordem de
        # retirada da pilha
        # empilhe p;
    if pri(p) == 4: # if it's an open parenthesis
         oppile.stack(p)
    if pri(p) == 5: # if it's a close parenthesis
        while len(oppile) > 0:
            pexpr.append(oppile.pop())
            if pri(oppile.top()) == 4:
                oppile.pop()
                break
         # desempilhe os operadores até o primeiro abre e coloque
         # na pós-fixa na mesma ordem de retirada da pilha;


while len(oppile) > 0:
    pexpr.append(oppile.pop())

# desempilhe todos os operadores que ainda estão na pilha e coloque na pós-fixa na mesma ordem de retirada da pilha
#



print(pexpr)        
# read the expression
while len(pexpr) > 1:
    for k in range(len(pexpr)):
        if pri(pexpr[k]) > 0:
            print('a')
            aux = op(pexpr[k-2], pexpr[k], pexpr[k-1])
            pexpr[k-2] = aux
            del pexpr[k-1]
            del pexpr[k-1]
            print(pexpr)
            break
print(pexpr[0])

